
\section{Architecture des modules}
\label{archi:modules}

\subsection{Interface Utilisateur}
\label{archi:modules:iu}

L'Interface Utilisateur (UserInterface) se charge de faire le lien entre
l'utilisateur et le programme, ses fonctions principales sont de lancer une
génération en appelant la fonction generate du module de génération. Lors
de l'appel à cette fonction, les paramètres entrés par l'utilisateur sont
transmis en paramètres. Lors du lancement du programme, une fonction
d'initialisation est lancée, elle permet d'assurer la présence de la Base de
Données et du/des modules de sortie.

\subsection{Générateur}
\label{archi:modules:generateur}

Le module de génération (caractérisé par 3 sous-modules: Generator, 
SimilarityEngine et FeedbackEngine) s'occupe de faire la génération de
playlist. Toutes les fonctions du sous-module Generator sont appelées par
l'interface utilisateur, et celui-ci appelle toutes les fonctions des deux
autres sous-modules. La fonction initialization sert à vérifier la présence de
base de données au démarrage du programme. 

La fonction generate sert à générer la playlist en fonction des options passées 
par l'interface utilisateur, cette fonction fera un appel à la fonction
select du module de données pour récupérer un ensemble fini de morceaux. La 
fonction regenerate est utilisée dans le cas particulier ou l'utilisateur se 
voit proposer de faire une re-génération dans le cas où la génération précédente 
est jugée non satisfaisante (voir le dossier d'Analyse de besoins). Cette 
fonction prend donc les options en paramètres et récupère la précèdente playlist 
générée pour l'améliorer.

Le similarityEngine sert à calculer la similarité entre deux 
morceaux afin de vérifier la validité de la playlist. Le feedback engine 
permet de communiquer avec l'interface utilisateur afin d'apporter un visuel 
de la génération en cours pour aider l'utilisateur à patienter.

\subsection{Module de données}
\label{archi:modules:donnees}

Le module de données (SQLiteDatabase) a pour objectif d'assurer la communication 
entre le module de génération et la base de données utilisée. Sa principale 
fonctionnalité est de réaliser une séléction dans la base de données selon le 
nombre de chansons souhaitées et les paramètres de séléction entrés par 
l'utilisateur, cette opération se fait par la fonction select.
De plus, lors du lancement du programme une fonction d'initialisation est 
appellée afin de certifier la présence de la Base de Données.

\subsection{Module de sortie}
\label{archi:modules:sortie}

Le module de sortie (ici TextFormatter) est en charge de fournir à 
l'utilisateur un moyen de récuperer le résultat de la génération demandée. Ce 
module (ainsi que tous les modules de sortie pouvant être crées) devront 
respecter l'interface Formatter, pour pouvoir être utilisé sur le programme. 
Dans le cas du module TextFormater le résultat obtenu sera mis sous la forme 
d'un fichier texte contenant les titres des différents morceaux de la playlist. 
Cette fontionnalité est assurée par la fonction format à laquelle on passe la 
playlist générée en paramètre.

\section{Structures de données}
\label{archi:structures}

\subsection{Morceau}
\label{archi:structures:morceau}

Un morceau (Track) est la structure principale du programme, elle peut être 
utilisée tant pour décrire un morceau que pour décrire des paramètres 
(certains paramètres seront utilisés uniquement dans le premier cas). Les 
paramètres sont triés dans deux sous-sections (signal\_data et context\_data) 
pour un soucis de visibilité à l'exception d'un id qui concerne l'identifiant 
dans la base de données du morceau (utilisé pour éviter des duplications).

\subsubsection{Données signal}
\label{archi:structures:morceau:signal}

Les données signal, représentées par la structure SignalData, sont l'ensemble 
des valeurs correspondant aux déscripteurs audio du morceau à savoir: le rythme, 
l'énergie et la tonalité (rythme, energy et tonality). Ces valeurs sont 
exprimées par des floats compris entre 0 et 1.

\subsubsection{Données de contexte}
\label{archi:structures:morceau:contexte}

Les données de contexte sont représentées par la structure ContextData. Cette 
structure contient les informations sur le morceaux qui ne sont pas relatives 
au signal, c'est à dire qui décrivent le contexte culturel du morceau. Ces 
informations sont un score de popularité compris entre 0 et 1, l'artiste qui 
en est à l'origine et l'album sur lequel il se trouve.

\subsubsection{Informations sur l'artiste et l'album}
\label{archi:structures:morceau:artiste}

Les informations sur l'artiste (Artist) contiennent un id (qui dépendra de la 
base de données), le nom de l'artiste interprète du morceau qui sera stocké dans 
une chaine de caractères ainsi qu'une liste d'artistes similaires.

L'album contient lui aussi un id, son nom (qui est utilisé pour la sortie dans 
le cas où c'est nécessaire), l'artiste de l'album (pouvant différer de celui du 
morceau dans le champ artiste par exemple dans le cas d'une collaboration avec 
un autre artiste), et l'année de sortie.

Ces deux sections appartienent aux données de contexte.

\subsection{Playlist et échantillon de morceaux}
\label{archi:structures:playlist}

La Playlist et l'échantillon de morceaux sont deux listes de morceaux, la 
première est remplie par le module de données et la deuxième par le générateur. 
La Playlist contient un booléen qui permet de renseigner la satisfaction ou non 
de la playlist à l'interface utilisateur, afin de proposer une re-génération à 
l'utilisateur.

\subsection{Paramètres}
\label{archi:structures:param}

Les paramètres du programme entrés par l'utilisateur seront représentés et 
stockés sous la forme d'un morceau. Les champs non-utilisés par le programme 
seront ignorés et les champs non-renseignés par l'utilisateur seront affectés 
à des valeurs spécifiques pour signaler qu'elles ne sont pas utilisés (les 
champs string seront vides, les champs float seront mis à 2 (puisque nous 
n'utilisons que des valeurs comprises entre 0 et 1) et les années de sortie 
en int seront mises à 0).