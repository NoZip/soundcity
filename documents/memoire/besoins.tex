\section{Analyse des besoins fonctionnels}
\label{besoins:fonc}

\subsection{Génération de Playlist}
\label{besoins:fonc:generation}

L’objectif principal de ce projet est de générer une liste cohérente de morceaux
selon des paramètres choisis par l’utilisateur. Cette génération se décompose en 2 parties distinctes.

\subsubsection{Sélection: interaction avec les données}
\label{besoins:fonc:generation:selection}

Durant l’étape de sélection, le programme doit être capable de choisir un ensembles
morceaux correspondant à un certain nombre de critères, tous étant optionnels, 
cette ensemble s'appelle la Pool de morceaux.
Dans le cas où aucun des paramètres optionnels n’est fixé, les pistes
sélectionnées doivent êtres aléatoires.

\vspace{3mm}
\noindent Les paramètres sont les suivants~:
\begin{itemize}
\item Durée de la playlist en temps ou en nombre de morceaux.
\item Le nom d'un artiste
\item Un tranche d'années
\item Un score de popularité
\end{itemize}

\vspace{3mm}
\noindent À ces données, on ajoute trois données basées sur le signal~:
\begin{description}
\item[Rythme~:] tout d’abord calculée d’après le tempo.
\item[Énergie~:] pouvant être calculée à partir du paramètre de «~loudness~».
\item[Humeur~:] pouvant être calculée en fonction de la tonalité du morceau (Note~: l’humeur
n’est pas nécessairement une donnée basée sur le signal, le client peut très bien
donner cette information en recueillant des avis d’utilisateurs).
\end{description}

Ces informations sont considérées exactes dans la base de données, elles sont 
toutes stockées dans des nombres flottant allant de 0 à 1, 
libre au créateur d'un nouvelle base de données d'imposer sa convention pour le calcul de ces valeurs.

\subsubsection{Ordonnancement: Similarité entre les morceaux}
\label{besoins:fonc:generation:selection:ordonnancement}

Durant l'ordonnancement, les morceaux placés dans la Pool de morceaux doivent être 
agencés en respectant une cohérence, mais aussi une variété. 
Un score de similarité doit donc pouvoir être calculé entre les morceaux pour 
choisir celui qui convient le mieux.

Ce calcul de similarité doit pouvoir donner un score de similarité entre 2 morceaux. 
Une playlist cohérente est donc une playlist dans laquelle chaque morceau doit 
avoir un score de similarité élevé avec le morceau qui le précède.

\subsection{Visualisation de la playlist}
\label{besoins:fonc:generation:visu}

La playlist doit pouvoir être utilisable après avoir été générée. IL faut donc un
moyen de la visualiser, et possiblement, de l’écouter.
Le moyen le plus simple, mais le plus rustique est le format textuel. Ce format
de sortie sera requis principalement pour les tests, son utilité est réduite dans
les autres cas.

Un autre moyen de visualiser la playlist est d’utiliser un service de streaming.
Celui qui a retenu notre attention est Deezer, car son API est en accès libre et
que la construction de playlist est assez simple. Il suffit en effet d’utiliser
une API javascript.
        
\subsection{Interface Utilisateur et feedback}
\label{besoins:fonc:generation:feedback}

Pour interagir avec le générateur, l’utilisateur doit passer par une interface
utilisateur (graphique ou en console) permettant de paramétrer le dit générateur.
De plus, dans le cas de certaines interfaces utilisateurs, il est important
d’envoyer un feedback des actions réalisées par le programme à l’utilisateur. Il
faudra donc utiliser un système nous permettant de visualiser l’avancement de la
génération.

\section{Analyse des besoins non fonctionnels}
\label{besoins:nfonc}

\subsection{Performances}
\label{besoins:nfonc:perf}

Les performances de la génération de la playlist sont importantes, car nous
voulons éviter de frustrer les utilisateurs avec un temps d'attente trop long.

Le feedback de l’interface permettra de réduire cette frustration, mais il faut
aussi raisonner en performance brute. Le nombre de pistes correspondants aux
critères rentrés par l’utilisateur peut être énorme. Il faut donc filtrer et
limiter le nombre de ces résultats, tout en conservant une notion d’aléatoire.

Nous avons donc décidé de limiter le nombre de morceaux sur lesquels faire nos
calculs et notre ordonnancement, les morceaux sélectionnés étant un sous ensemble
plus petit des morceaux correspondant aux critères choisis. Notre convention est
donc de limiter ce sous ensemble de pré-sélection à 10 fois la taille de playlist
demandée par l’utilisateur, ainsi pour une génération de 15 morceaux, une 
préselection de 150 morceaux sera faite et la génération sera effectuée depuis uniquement ces morceaux.
Ce système permet de limiter la complexité d'une génération. Chaque morceau de
la pool est comparé à tous les autres à chaque insertion de nouveau track dans la 
playlist, la complexité est donc de \[O(n) = n*(n*10)\], n étant la taille de la playlist générée.

\subsection{Modularité}
\label{besoins:nfonc:perf:mod}
    
Le projet se doit de pouvoir avoir chacune de ses parties indépendantes et
remplaçables à souhait. Pour cela, le programme sera séparé en 4 modules~:

\subsubsection{Module d'Interface Utlisateur}
\label{besoins:nfonc:perf:mod:iu}

(c.f. Section \ref{besoins:fonc:generation:feedback})

\subsubsection{Module de génération de playlist}
\label{besoins:nfonc:perf:mod:generator}

Le module est chargé de générer la liste de morceaux en fonction d’un panel de
descripteurs de morceaux et de paramètres, il s'agit de la partie d'ordonancement. 
Il est lié au modules de données (c.f. Section \ref{besoins:nfonc:perf:mod:data}) 
qui se chargera de la selection des morceaux.

\subsubsection{Statégie de similarité}
\label{besoins:nfonc:perf:mod:similarity}

Ce module utilisera le pattern Strategy pour le rendre interchangeable. 
Cette classe contiendra une fonction qui calculera le score de similarité entre 
deux morceaux passés en paramètres, elle sera appellée uniquement par le générateur.

\subsubsection{Module de données}
\label{besoins:nfonc:perf:mod:data}

Cette partie est chargée de récupérer les données pour alimenter le générateur.
Elle peut être changée en fonction du type de données à lire (fichier(s), base de
données, etc). Nous ne ferons qu’un seul module qui travaillera sur une base de
données SQL.

\subsubsection{Module de sortie}
\label{besoins:nfonc:perf:mod:out}

Il peut y avoir plusieurs modules de sorties s'imbriquant dans le programme, mais
il en faut au minimum une. Cette partie se charge de convertir puis de rendre à
l’utilisateur la playlist (déjà générée par le module de génération) à son format
propre.

\begin{figure}[H]
\includegraphics[width=\textwidth]{data/besoins/modules.png}
\caption{Les 4 modules indispensables au bon fonctionnement du programme et leurs
interactions.}
\end{figure}

\subsection{Ergonomie}
\label{besoins:nfonc:perf:erg}
Les interfaces utilisateurs devront être utilisables par un utilisateur
non-avancé, être claires et précises, et éviter de perdre l’utilisateur. Les
termes employés sur cette interface devront être écrit dans un vocabulaire
compréhensible de tous.

\section{Contraintes}
\label{besoins:contraintes}

\subsection{Base de données}
\label{besoins:contraintes:bdd}
Nous ne disposons pas d’analyseur de morceaux, et en créer un ne fait pas partie
de notre sujet. Nous devons donc utiliser nous-même une base de données déjà
existante afin de travailler dessus. Nous avons donc choisi d’utiliser la Million
Song Dataset (http://labrosa.ee.columbia.edu/millionsong/) qui contient toutes
les informations dont nous avons besoin. Nous la convertirons en base de données
SQL pour améliorer le temps de récupération des données. Il va donc falloir comprendre
le fonctionnement de la MSD afin de pourvoir créer un script qui permettera d'en extraire 
les informations et créer une base de données MySQL.
    
Cette base de données pèse 500Go, la conversion doublera la place nécessaire pour
stocker nos bases de données. Bien que nous travaillerons sur un échantillon
restreint au départ, nous devrons disposer d’un espace de travail d’au moins 1
téraoctet. Nous allons au préalabre travailler sur cet échantillon pour un gain de temps
de convertion et de stockage.

La MSD est la seule base pouvant nous servir de test, et les informations qu'elle contient
sont parfois très inexactes voire complétement absentes, nous devons faire abstraction de
ces cas particuliers même si ils peuvent nous poser des problèmes dans le cadre des tests
(puisque nous considérons les informations toutes rensignées et correctes).

\section{Prototypes}
\label{besoins:proto}

\subsection{Interface utilisateur graphique}
\label{besoins:proto:gui}
    
L'idée de notre interface graphique est de permettre à un utilisateur non aguérri
de faire fonctionner notre programme sans avoir de grandes connaissances en
informatique musicale. C'est pourquoi nous avons choisi de réaliser une interface
graphique simple et au vocabulaire accessible. Par exemple, l'energie du morceau
sera représentée par un curseur pouvant varier de «~léger~» à «~puissant~», sans
proposer à l'utilisateur de choisir une valeur numérique précise, qui ne
représenterait rien à ses yeux.
    
Les différents paramètres d'entrée sont ainsi organisés de façon à partir du plus
basique au plus complèxe, en regroupant les paramètres dits contextuels (artiste,
genre etc.) en haut et les desripteurs audio en dessous (rythme, énergie, etc.).

Enfin nous proposons d'inclure des checkboxs afin que l'utilisateur puisse
choisir quels paramètres il veut ou non prendre en compte, et ainsi lui laisser
la possibilité de choisir le degré de spécification de la playlist.
    
\begin{figure}[H]
\includegraphics[width=\textwidth]{data/besoins/interface_utilisateur.png}
\caption{Prototype de l'interface utilisateur graphique.}
\end{figure}

\subsection{Interface utilisateur console}
\label{besoins:proto:console}

Cette interface aura les mêmes fonctionnalités que l'interface console, à la différence que tous les options seront placées lors de l'appel du programme :

\vspace{3mm}
\noindent Les paramètres sont les suivants~:
\begin{itemize}
\item \texttt{-y <startYear[1-3000]> <endYear[1-3000]>} : Définit un intervalle 
d'années de morceaux.
\item \texttt{-e <energy[0.0-1.0]>} : Impose une valeur d'énergie dans 
la playlist générée.
\item \texttt{-p <popularity[0.0-1.0]>} : Impose une valeur de popularité 
dans la playlist générée.
\item \texttt{-r <rhythm[0.0-1.0]>} : Impose un rythme dans la 
playlist générée.
\item \texttt{-m <mood[0.0-1.0]>} : Impose une humeur dans la 
playlist générée (plus la valeur est grande plus le morceau est joyeux).
\item \texttt{-s <size[1-100]>} : Choix de la taille de la 
playlist générée (10 par défaut).
\item \texttt{-o <fileName>} : Choix du nom du fichier de sortie.
\item \texttt{-a <artistName>} : Impose un artiste.
\end{itemize}

\subsection{Base de données}
\label{besoins:proto:bdd}

La base de données que nous utiliserons sera une conversion en base SQL de la Million Song Database dont nous extrairons uniquement les valeurs dont nous avons besoin.
